
心血来潮，翻译`Git User Manual`。只翻译重点语句、我认为有用的语句。

[TOC]

# Part I. 仓库和分支 #
## 章节1  如何获得一个Git仓库 ##
最好的方式是使用`git-clone`命令下载一个已经存在的仓库，如果没有可以使用下面的例子：
```
	# Git itself (approx. 40MB download):
$ git clone git://git.kernel.org/pub/scm/git/git.git
	# the Linux kernel (approx. 640MB download):
$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
```

## 章节2  如何从工程检出一个不同的版本 ##
Git被认为是最好的存储文件集合的历史的工具。它把历史存储为工程内容相互关联的快照的压缩集合。在Git中每一个版本称为**commit**。这些快照并不是必须得按照从旧到新的顺序排成一列，相反地，可能是多个并行的开发同时进行，称之为**分支**，分支可以合并也可以分叉。

一个单个的Git仓库能够跟踪开发过程中的多个分支。它是通过保存一列指向每个分支最新的提交的**heads**来实现的。`git branch`命令显示一列分支头：
```
$ git branch
* master
```

大多数的工程也使用了**tags**.标签就像头一样，也是指向工程的历史，通过命令`git tag`列出所有的标签：
```
$ git tag -l
v2.6.11
v2.6.11-tree
v2.6.12
v2.6.12-rc2
v2.6.12-rc3
v2.6.12-rc4
v2.6.12-rc5
v2.6.12-rc6
v2.6.13
...
```

标签是预期用来一直指向工程中的同一个版本，而头指针是预期随着开发进程向前推进的。

创建一个分支头指向某个版本然后检出这个分支，可以使用命令`git-checkout`:
```
$ git checkout -b new v2.6.13
```

工作目录现在更新为标签v2.6.13时的内容，而且`git-branch`显示两个分支，星号指示当前检出的分支：
```
$ git branch
  master
* new
```

如果你决定更希望看到版本v2.6.17，那么使用下面的命令让当前分支指向v2.6.17:
```
$ git reset --hard v2.6.17
```

**注意**：如果当前分支头指针是你惟一一个执行历史中特定的点，那么重置分支可能会让你没有办法找到它曾经指向的历史，所以要谨慎地使用这条命令。


## 章节3  理解历史：提交 ##
工程历史的每次的变化都由一个提交来表示。命令`git-show`显示当前分支最近的一次提交：
```
$ git show
commit 17cf781661e6d38f737f15f53ab552f1e95960d7
Author: Linus Torvalds <torvalds@ppc970.osdl.org.(none)>
Date:   Tue Apr 19 14:11:06 2005 -0700

    Remove duplicate getenv(DB_ENVIRONMENT) call

    Noted by Tony Luck.

diff --git a/init-db.c b/init-db.c
index 65898fa..b002dc6 100644
--- a/init-db.c
+++ b/init-db.c
@@ -7,7 +7,7 @@

 int main(int argc, char **argv)
 {
-	char *sha1_dir = getenv(DB_ENVIRONMENT), *path;
+	char *sha1_dir, *path;
 	int len, i;

 	if (mkdir(".git", 0755) < 0) {
```

一个提交可以显示是谁做了最近的修改，它们做了什么，原因是什么。

每一个提交都有一个40位的十六进制的ID，又称为**对象名字**或者**SHA-1 ID**，正如上面的`git show`命令输出的第一行所示。引用一个提交可以使用简短的名字，例如一个标签或者分支名字，但是这个更长的名字也有用。最为重要的是，对于这个提交它是全球唯一的名字，因此假如你告诉某个人对象的名字（例如在邮件中），你可以保证这个名字指向他们仓库中同样的提交，正如它指向你仓库中同样的提交（假如他们仓库中也有这个提交）。既然对象名字是把提交内容经过hash算出来的，你可以保证提交不变它的名字也不变。

### 理解历史：提交，父辈，可存取性 ###
每一个提交（除了工程中的第一个提交）都有一个父辈提交，父辈提交显示了在这个提交之前发生了什么。跟着父辈链条往前最终会追溯到这个工程的开始。然而Git允许多个开发同时进行，开发中两个分支的重新汇合称为**merge**，代表merge的这个提交有两个父辈，每一个父辈代表那个开发中最近的提交。

在下面，我们这样称呼：如果提交X是提交Y的父辈，就说提交X是提交Y可以存取的。同样的，也可以说提交Y是提交X的后代。

### 理解历史：历史图表 ###
我们可以使用图表来表示Git提交历史。每一个提交用**o**表示，时间从左到右。

```
         o--o--o <-- Branch A
        /
 o--o--o <-- master
        \
         o--o--o <-- Branch B
```

### 理解历史：分支是什么 ###
为了精准性，我们使用**分支**来表示一条开发线，使用**分支头**（又或者**头指针**）来表示那个分支最近的一个提交。在上面的例子中，分支头指针A指向一个特定的提交，但当我们引用这个提交一条线上的3个提交把它们看做是分支A的一部分。

不管怎样，只要不产生混淆，我们通常使用**分支**指代分支和分支头。

